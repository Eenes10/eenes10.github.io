<!--
This single HTML file includes the updated Trigonometrik Deƒüer Hesaplayƒ±cƒ± with:
- Grafiksel trigonometrik fonksiyon g√∂sterimi (canvas plot + marker for angle)
- Kayan arka plan grid animasyonu
- Mikro animasyonlar (buton hover, result pulse, spotlight)
- Modern SVG minimal ikonlar embedded
- PWA support: service worker registration included below and a manifest content provided (save separately as manifest.json)

FILES TO SAVE FOR PWA (create these two files on your server alongside this HTML):
1) manifest.json
{
  "name": "Trigonometrik Deƒüer Hesaplayƒ±cƒ±",
  "short_name": "TrigCalc",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#e6f2ff",
  "theme_color": "#6c74ff",
  "icons": [
    { "src": "icons/icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "icons/icon-512.png", "sizes": "512x512", "type": "image/png" }
  ]
}

2) service-worker.js
// Minimal service worker for offline-first caching
const CACHE_NAME = 'trig-calc-v1';
const ASSETS = ['/', '/trig-calculator-v2.html'];
self.addEventListener('install', event => {
  event.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(ASSETS)));
  self.skipWaiting();
});
self.addEventListener('activate', event => { event.waitUntil(self.clients.claim()); });
self.addEventListener('fetch', event => {
  event.respondWith(caches.match(event.request).then(r => r || fetch(event.request)));
});

Notes:
- Serve the page over HTTPS (or use localhost) for the service worker and PWA install to work.
- Put icons in an /icons/ folder or edit manifest icons.
-->

<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trigonometrik Deƒüer Hesaplayƒ±cƒ± ‚Äî Eƒülenceli (v2)</title>
<link rel="manifest" href="/manifest.json">
<style>
  :root{
    --card-w:760px;
    --accent1:#6c74ff;
    --accent2:#34d399;
    --bg1:#e6f2ff;
    --bg2:#bfe0ff;
    --glass: rgba(255,255,255,0.88);
    --muted:#445a78;
    --shadow: 0 18px 40px rgba(13,38,76,0.12);
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Arial,Helvetica,sans-serif}
  html,body{height:100%;margin:0}
  body{
    background: linear-gradient(160deg,var(--bg1),var(--bg2));
    display:flex;align-items:center;justify-content:center;padding:28px;color:#07204a;overflow:hidden;
  }

  /* animated grid background */
  .bg-grid{
    position:fixed;inset:0;z-index:0;pointer-events:none;opacity:0.28;
    background-image: repeating-linear-gradient(0deg, rgba(10,20,40,0.04) 0 1px, transparent 1px 28px),
                      repeating-linear-gradient(90deg, rgba(10,20,40,0.03) 0 1px, transparent 1px 28px);
    background-size: 100% 100%;
    animation: gridPan 40s linear infinite;
    mix-blend-mode:multiply;
  }
  @keyframes gridPan{from{background-position:0 0}to{background-position:400px 400px}}

  .spot {
    position:fixed; left:0; top:0; width:100%; height:100%;
    pointer-events:none; mix-blend-mode:screen; z-index:1; filter: blur(10px);
    background: radial-gradient(circle 160px at var(--x,50%) var(--y,50%), rgba(255,255,255,0.92), rgba(255,255,255,0.18) 30%, rgba(200,214,255,0.06) 60%, transparent 70%);
  }

  .container{position:relative;z-index:2;width:var(--card-w);padding:18px;border-radius:14px;background:var(--glass);backdrop-filter:blur(8px) saturate(120%);box-shadow:var(--shadow)}
  header{display:flex;align-items:center;gap:12px;justify-content:space-between}
  h1{font-size:18px;margin:0;font-weight:800}
  .controls{display:flex;gap:8px;align-items:center}

  /* function and unit row */
  .func-row{display:flex;gap:8px;margin:12px 0}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:9px 12px;border-radius:10px;border:0;background:#f6f9ff;cursor:pointer;font-weight:700;box-shadow:0 6px 18px rgba(10,20,40,0.05);transition:transform .14s,box-shadow .14s,background .14s}
  .btn:hover{transform:translateY(-3px)}
  .btn.active{background:linear-gradient(90deg,var(--accent1),#8a90ff);color:white;box-shadow:0 14px 40px rgba(106,115,255,0.16)}

  .field{display:flex;gap:8px;align-items:center;margin-top:8px}
  input[type=number]{padding:10px 12px;border-radius:10px;border:1px solid #d6e7ff;width:140px}
  .unit-toggle{display:flex;gap:6px}
  .unit-toggle .btn{padding:8px 10px;font-weight:700}

  /* layout: left plot, right controls */
  .main{display:grid;grid-template-columns:1fr 320px;gap:12px;align-items:start}
  .plot-card{border-radius:12px;padding:12px;background:linear-gradient(180deg,#fff,#f8fbff);box-shadow:inset 0 1px 0 rgba(255,255,255,0.6)}
  canvas{width:100%;height:240px;border-radius:8px;background:linear-gradient(180deg,#fbfdff,#eef8ff);display:block}

  .side{display:flex;flex-direction:column;gap:10px}
  .actions{display:flex;gap:8px}
  .calc-btn{flex:1;padding:12px;border-radius:12px;border:0;background:linear-gradient(90deg,var(--accent2),#0fb07b);color:white;font-weight:800;cursor:pointer}

  .result{border-radius:12px;padding:12px;background:linear-gradient(180deg,#fff,#f7fbff);min-height:72px;display:flex;flex-direction:column;gap:6px}
  .exact{font-weight:800;color:#0b2b52;font-size:15px}
  .approx{color:#556b86;font-size:13px}

  /* micro animations */
  .pulse{animation:pulse 1.2s ease-in-out}
  @keyframes pulse{0%{transform:scale(1);box-shadow:0 0 0 rgba(100,116,255,0.12)}50%{transform:scale(1.02);box-shadow:0 18px 40px rgba(100,116,255,0.08)}100%{transform:scale(1);box-shadow:0 0 0 rgba(100,116,255,0)}}

  /* icons */
  .icon{width:18px;height:18px;display:inline-block}

  /* responsive */
  @media (max-width:860px){:root{--card-w:94vw}.main{grid-template-columns:1fr}.plot-card canvas{height:200px}}
</style>
</head>
<body>
  <div class="bg-grid"></div>
  <div class="spot" id="spot"></div>

  <div class="container">
    <header>
      <div style="display:flex;align-items:center;gap:12px">
        <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2v20M2 12h20" stroke="#6c74ff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <h1>Trigonometrik Deƒüer Hesaplayƒ±cƒ±</h1>
      </div>
      <div class="controls">
        <button id="themeToggle" class="btn" title="Karanlƒ±k / A√ßƒ±k">üåô Tema</button>
        <button id="installBtn" class="btn" style="display:none">‚¨áÔ∏è Uygulamayƒ± Ekle</button>
      </div>
    </header>

    <div class="func-row" id="funcRow">
      <button class="btn active" data-f="sin">sin</button>
      <button class="btn" data-f="cos">cos</button>
      <button class="btn" data-f="tan">tan</button>
      <button class="btn" data-f="cosec">cosec</button>
      <button class="btn" data-f="sec">sec</button>
      <button class="btn" data-f="cot">cot</button>
    </div>

    <div class="main">
      <div class="plot-card">
        <canvas id="plotCanvas" width="800" height="320" aria-label="Trigonometrik fonksiyon grafiƒüi"></canvas>
        <div style="display:flex;align-items:center;gap:8px;margin-top:10px">
          <label style="font-weight:700">A√ßƒ±:</label>
          <input id="angle" type="number" inputmode="decimal" value="30" />
          <div class="unit-toggle">
            <button id="degBtn" class="btn active">¬∞</button>
            <button id="radBtn" class="btn">rad</button>
          </div>
        </div>
        <input id="angleRange" type="range" min="-360" max="360" step="0.1" value="30" style="width:100%;margin-top:10px">
      </div>

      <div class="side">
        <div style="display:flex;gap:8px">
          <button id="calcBtn" class="calc-btn">Hesapla ‚ú®</button>
          <button id="histBtn" class="btn">üìú</button>
        </div>

        <div class="result" id="result">
          <div class="exact" id="exact">‚Äî</div>
          <div class="approx" id="approx">Sonu√ß burada g√∂r√ºnecek.</div>
        </div>

        <details>
          <summary style="cursor:pointer;padding:8px 10px;border-radius:10px;background:#fff;">Form√ºller</summary>
          <div style="padding:8px 12px">sin¬≤x + cos¬≤x = 1<br>1 + tan¬≤x = sec¬≤x<br>sin(Œ±¬±Œ≤)=sinŒ±cosŒ≤¬±cosŒ±sinŒ≤</div>
        </details>
      </div>
    </div>
  </div>

<script>
// === small utility expressions parser (same as your original) ===
function parseExactStringToNumber(s){
  if(!s || s==='‚Äî') return NaN;
  if(s === 'Tanƒ±msƒ±z') return NaN;
  s = s.replace(/\s+/g,'');
  let numerator = s; let denom = 1;
  if(s.includes('/')){
    const parts = s.split('/');
    numerator = parts.slice(0,parts.length-1).join('/');
    denom = Number(parts[parts.length-1]);
    if(Number.isNaN(denom)) denom = parseTerm(parts[parts.length-1]);
  }
  if(numerator.startsWith('(') && numerator.endsWith(')')) numerator = numerator.slice(1,-1);
  const tokens = numerator.match(/[+-]?[^+-]+/g) || [];
  let total = 0; for(let token of tokens) total += parseTerm(token);
  return total / denom;
}
function parseTerm(token){
  token = token.trim(); if(token === '') return 0; if(token[0] === '+') token = token.slice(1);
  if(token.includes('‚àö')){
    token = token.replace(/\(/g,'').replace(/\)/g,'');
    let sign = 1; if(token[0] === '-'){ sign=-1; token=token.slice(1);} if(token[0]==='+') token=token.slice(1);
    const m = token.match(/^(\d*\.?\d*)?‚àö(\d+(?:\.\d+)?)$/);
    if(m){ const coeff = m[1] ? Number(m[1]) : 1; const rad = Number(m[2]); return sign * coeff * Math.sqrt(rad); }
  }
  const n = Number(token); if(!Number.isNaN(n)) return n;
  const parts = token.match(/[+-]?[^+-]+/g);
  if(parts && parts.length>1){ let s=0; for(const p of parts) s+=parseTerm(p); return s; }
  return 0;
}

// === exact map (trimmed for brevity) ===
const exactValues = { sin:{0:'0',15:'(‚àö6-‚àö2)/4',30:'1/2',45:'‚àö2/2',60:'‚àö3/2',90:'1',180:'0'}, cos:{0:'1',30:'‚àö3/2',45:'‚àö2/2',60:'1/2',90:'0',180:'-1'}, tan:{0:'0',30:'1/‚àö3',45:'1',60:'‚àö3',90:'Tanƒ±msƒ±z'} };

// DOM refs
const funcButtons = Array.from(document.querySelectorAll('.func-row .btn'));
const angleInput = document.getElementById('angle');
const angleRange = document.getElementById('angleRange');
const degBtn = document.getElementById('degBtn');
const radBtn = document.getElementById('radBtn');
const calcBtn = document.getElementById('calcBtn');
const exactEl = document.getElementById('exact');
const approxEl = document.getElementById('approx');
const plotCanvas = document.getElementById('plotCanvas');
const ctx = plotCanvas.getContext('2d');
let currentFunc = 'sin'; let unit='deg'; let history = JSON.parse(localStorage.getItem('trig_history_v2')||'[]');

// set active func
funcButtons.forEach(b=>b.addEventListener('click', ()=>{ funcButtons.forEach(x=>x.classList.remove('active')); b.classList.add('active'); currentFunc = b.dataset.f; drawPlot(); }));

degBtn.addEventListener('click', ()=>{ unit='deg'; degBtn.classList.add('active'); radBtn.classList.remove('active'); syncInputs(); drawPlot(); });
radBtn.addEventListener('click', ()=>{ unit='rad'; radBtn.classList.add('active'); degBtn.classList.remove('active'); syncInputs(); drawPlot(); });

angleInput.addEventListener('input', ()=>{ syncRange(); drawPlot(); });
angleRange.addEventListener('input', ()=>{ syncInputs(true); drawPlot(); });

function syncRange(){ const val = angleInput.value || 0; angleRange.value = (unit==='deg')?val: (Number(val)*(180/Math.PI)); }
function syncInputs(fromRange){ if(fromRange){ const v = Number(angleRange.value); angleInput.value = (unit==='deg')? v : (v*Math.PI/180); } else { syncRange(); } }

// compute trig
function computeTrigValue(fn, rad){ switch(fn){ case 'sin': return Math.sin(rad); case 'cos': return Math.cos(rad); case 'tan': return Math.tan(rad); case 'cosec': return 1/Math.sin(rad); case 'sec': return 1/Math.cos(rad); case 'cot': return 1/Math.tan(rad); } }

function showResult(exactStr, approxNum){ exactEl.classList.remove('pulse'); approxEl.classList.remove('pulse'); void exactEl.offsetWidth; exactEl.textContent = exactStr || ''; approxEl.textContent = (approxNum===null)? 'Tanƒ±msƒ±z' : (typeof approxNum==='number'? approxNum.toFixed(6): approxNum); exactEl.classList.add('pulse'); approxEl.classList.add('pulse'); }

calcBtn.addEventListener('click', ()=>{
  const raw = angleInput.value.trim(); if(raw===''){ showResult('', 'L√ºtfen a√ßƒ± girin.'); return; }
  const parsed = Number(raw); if(Number.isNaN(parsed)){ showResult('', 'Ge√ßerli sayƒ± girin.'); return; }
  let degForLookup = (unit==='deg')? parsed : (parsed*180/Math.PI);
  degForLookup = Math.round(degForLookup*10000)/10000;
  const intDeg = Math.round(degForLookup); const isIntegerAngle = Math.abs(intDeg - degForLookup) < 1e-9;
  const fnMap = exactValues[currentFunc];
  if(isIntegerAngle && fnMap && fnMap[intDeg] !== undefined){ const exact = fnMap[intDeg]; const approx = parseExactStringToNumber(exact); showResult(exact, approx); pushHistory(`${currentFunc} ${intDeg}¬∞ = ${approx.toFixed(6)}`); return; }
  const angleRad = (unit==='deg')? parsed*Math.PI/180 : parsed;
  const val = computeTrigValue(currentFunc, angleRad);
  if(!isFinite(val)){ showResult('', 'Tanƒ±msƒ±z'); pushHistory(`${currentFunc} ${parsed} ${unit} = Tanƒ±msƒ±z`); return; }
  showResult('', val); pushHistory(`${currentFunc} ${parsed} ${unit} = ${val.toFixed(6)}`);
});

function pushHistory(text){ history = history||[]; history.push(text); if(history.length>80) history.shift(); localStorage.setItem('trig_history_v2', JSON.stringify(history)); }
document.getElementById('histBtn').addEventListener('click', ()=>{ alert(history.slice().reverse().join('\n')||'Hen√ºz ge√ßmi≈ü yok'); });

// spotlight follow
const spot = document.getElementById('spot'); document.addEventListener('mousemove', (e)=>{ spot.style.setProperty('--x', e.clientX+'px'); spot.style.setProperty('--y', e.clientY+'px'); });

// theme toggle (persist)
const themeToggle = document.getElementById('themeToggle'); (function initTheme(){ const stored = localStorage.getItem('trig_theme'); if(stored==='dark') document.documentElement.classList.add('dark'); themeToggle.addEventListener('click', ()=>{ document.documentElement.classList.toggle('dark'); localStorage.setItem('trig_theme', document.documentElement.classList.contains('dark')? 'dark':'light'); }); })();

// install prompt handling
let deferredPrompt; const installBtn = document.getElementById('installBtn'); window.addEventListener('beforeinstallprompt', (e)=>{ e.preventDefault(); deferredPrompt = e; installBtn.style.display = 'inline-flex'; }); installBtn.addEventListener('click', async ()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); const choice = await deferredPrompt.userChoice; deferredPrompt = null; installBtn.style.display='none'; });

// draw plot
function drawPlot(){ const w = plotCanvas.width = plotCanvas.clientWidth*devicePixelRatio; const h = plotCanvas.height = 240*devicePixelRatio; ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); ctx.clearRect(0,0,plotCanvas.clientWidth,240);
  const padding = 32; const W = plotCanvas.clientWidth - padding*2; const H = 200; const cx = padding; const cy = padding + H/2;
  // background grid
  ctx.strokeStyle = 'rgba(10,20,40,0.06)'; ctx.lineWidth = 1; for(let x=0;x<=W;x+=20){ ctx.beginPath(); ctx.moveTo(cx+x, padding); ctx.lineTo(cx+x, padding+H); ctx.stroke(); }
  for(let y=0;y<=H;y+=20){ ctx.beginPath(); ctx.moveTo(cx, padding+y); ctx.lineTo(cx+W, padding+y); ctx.stroke(); }
  // axes
  ctx.strokeStyle = 'rgba(10,20,40,0.18)'; ctx.lineWidth = 1.2; ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+W, cy); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx+W/2, padding); ctx.lineTo(cx+W/2, padding+H); ctx.stroke();
  // plot function (x domain -2œÄ..2œÄ)
  const domainMin = -2*Math.PI; const domainMax = 2*Math.PI; function xToPx(x){ return cx + ( (x - domainMin)/(domainMax-domainMin) ) * W; }
  function yToPx(y){ const scale = H/2; return cy - y*scale; }
  ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(108,116,255,0.92)';
  const steps = 800; for(let i=0;i<=steps;i++){ const t = domainMin + (i/steps)*(domainMax-domainMin); let y = 0; try{ y = computeTrigValue(currentFunc, t); }catch(e){ y = NaN; }
    if(!isFinite(y)) { ctx.moveTo(xToPx(t), yToPx(0)); continue; }
    const px = xToPx(t), py = yToPx(Math.max(-3,Math.min(3,y))); if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  } ctx.stroke();
  // draw marker for current angle
  const angleVal = Number(angleInput.value) || 0; const angleRad = (unit==='deg') ? angleVal*Math.PI/180 : angleVal; const markerX = xToPx(angleRad);
  ctx.fillStyle = '#ff6b6b'; ctx.beginPath(); ctx.arc(markerX, yToPx(Math.max(-3,Math.min(3, computeTrigValue(currentFunc, angleRad)))), 6,0,Math.PI*2); ctx.fill();
  // labels
  ctx.fillStyle = '#274060'; ctx.font = '12px Inter, system-ui'; ctx.fillText('-2œÄ', cx+2, padding+H+14); ctx.fillText('0', cx+W/2-6, padding+H+14); ctx.fillText('2œÄ', cx+W-22, padding+H+14);
}

// initial draw
drawPlot(); window.addEventListener('resize', ()=> drawPlot());

// PWA: register service worker if available
if('serviceWorker' in navigator){ navigator.serviceWorker.register('/service-worker.js').catch(()=>{}); }

</script>
</body>
</html>
